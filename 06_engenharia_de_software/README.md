# Engenharia de Software

## Introdução à engenharia de software

### Quem é o engenheiro de software

- O engenheiro de software é o profissional responsável pelo desenvolvimento e pela implantação de produtos, serviços e sistemas de software, desde a ideia inicial até o produto final;
- De acordo com o IEEE (Institute of Electrical and Electronic Engineers) – entidade internacional que definiu as diretrizes dessa área – engenharia de software trata-se da “aplicação de uma abordagem sistemática, disciplinada e quantificável no desenvolvimento, na operação e na manutenção de software, isto é, a aplicação de engenharia ao software” (IEEE apud PRESSMAN; MAXIM, 2016);
- Assim que se gradua, um engenheiro de software deve ser capaz de coordenar projetos, administrar equipes de trabalho e, inclusive, gerenciar conflitos que podem surgir durante o processo de desenvolvimento;
- O engenheiro de software deve, portanto, "fornecer aos desenvolvedores (inclusive gerentes, analistas e designers) as ferramentas e processos que deverão ser usados e será o responsável por verificar se esse uso está sendo feito efetivamente e de forma otimizada" (WAZLAWICK, 2013, p. 19);
- Existem diferenças entre as áreas de engenharia de software, engenharia da computação e ciência da computação:
  - O engenheiro de software atua em projeto, desenvolvimento e implantação de software;
  - O engenheiro da computação se volta ao desenvolvimento de hardware, como computadores e equipamentos eletrônicos;
  - O cientista da computação, por sua vez, desenvolve os modelos matemáticos, os algoritmos e as demais ferramentas teóricas que serão utilizados pelo engenheiro de software, o qual é, portanto, o elo de ligação entre os demais profissionais de TI;
- Conforme dados da ABES (Associação Brasileira de Empresas de Software), o Brasil está em 1º lugar na América Latina em investimentos na área de software, e em 9º lugar mundialmente;
- O engenheiro de software é o responsável pela gestão consciente de recursos humanos, de materiais financeiros e tecnológicos necessários para o desenvolvimento do software e de processos de desenvolvimento, desde a coleta de requisitos até a entrega do software em sua versão final;
- A atividade do engenheiro de software está sendo regulamentada pela Resolução n. 1.100 do CONFEA (Conselho Federal de Engenharia e Agronomia), a qual defende que esse profissional integra o grupo dos engenheiros eletricistas, tendo direitos e deveres de um engenheiro conforme a legislação em vigor (CONFEA, 2018).

### A prática da engenharia de software

- O engenheiro de software é um profissional de inovação e um projetista;
- A inovação em engenharia de software pode acontecer de diferentes formas:
  - A primeira, mais frequente, é denominada **inovação incremental** ou melhoria contínua;
  - A segunda, denominada **inovação radical**, consiste na criação de algo totalmente novo, do "zero".
- Métodos do desenvolvimento de software:
  - **Engenharia de requisitos**: consiste na definição, com a participação do cliente ou usuário, do que o software necessita ter em termos de funcionalidade, requisitos de segurança, aparência das telas, botões, menus, compatibilidade com sistemas operacionais específicos, dentre outros;
  - **Planejamento**: é a fase criativa do desenvolvimento de software. Envolve definir a sua arquitetura; criar esboços das telas; definir os diagramas básicos (diagramas de classes e atividades, por exemplo) e as linguagens de programação a serem utilizadas para cada funcionalidade do software;
  - **Desenvolvimento ou codificação do software**: é a fase de desenvolvimento do software, durante o processo de desenvolvimento, podem surgir incidentes ou problemas, forçando o projeto a ser modificado, ou erros podem passar despercebidos e somente aparecer quando o software estiver concluído;
  - **Fase de testes**: após desenvolvido e codificado, o software deve ser testado – atividade que deve ser repetida sempre que necessária. Isso se deve porque erros – mais conhecidos como bugs – podem custar caro, principalmente se o software já estiver em fase de lançamento;
  - **Manutenção e melhorias**: após o software ser desenvolvido e lançado, é necessária a realização de manutenção e melhorias contínuas.
- Além dos cinco métodos descritos, é importante ressaltar que, como em toda profissão, a prática de engenharia de software deve se ater a princípios éticos, de modo que os resultados do trabalho do profissional não prejudiquem a si e a organização ou o cliente.

### O engenheiro de software e outros profissionais

- Em uma organização, o engenheiro de software pode assumir várias funções, atuando no desenvolvimento de software, na gestão de equipes ou mesmo como consultor;
- O engenheiro de software é um profissional que trabalha com equipes de diferentes áreas do conhecimento;
- Constantine (1993 apud PRESSMAN; MAXIM, 2016) enumera paradigmas, ou padrões, para a formação de equipes de desenvolvimento:
  - **Paradigma fechado**: a principal característica é a existência de uma hierarquia formal entre gestores e colaboradores, em que se predomina a ordem. Porém, essa estrutura pode não ser ideal quando se necessita desenvolver a criatividade e a inovação nas equipes de trabalho, uma vez que a comunicação entre os membros, nesse paradigma, tende a ser mais restrita;
  - **Paradigma randômico**: o que predomina é a iniciativa individual dos membros da equipe. Opostamente ao paradigma fechado, esse é mais adequado para o desenvolvimento de inovações. Porém, por depender de decisões individuais, podem surgir conflitos, caso seja preciso agir de modo mais ordenado, uma vez que nesse paradigma a possibilidade de surgirem divergências de opiniões é maior;
  - **Paradigma sincronizado**: o problema é segmentado de modo que os membros da equipe organizem-se para que cada um trabalhe em uma parte. Porém, a comunicação entre os membros, nesse caso, é prejudicada, uma vez que cada equipe, desenvolvendo apenas uma parte do software, terá conhecimento somente da parte que desenvolve, tendo pouco ou nenhum conhecimento das demais partes;
  - **Paradigma aberto**: predominam-se a colaboração, a comunicação e o consenso nas decisões. Para projetos inovadores e mais complexos, equipes estruturadas nesse paradigma tendem a se destacar;
- Sommerville (2011) enumera quatro fatores essenciais no gerenciamento de equipes:
  - **Consistência**: diz respeito à valorização por igual de cada membro da equipe, considerando que as pessoas não devem sentir que seu trabalho é desvalorizado ou subvalorizado;
  - **Inclusão**: é derivada da consistência. Uma vez que o trabalho de um profissional deve ser valorizado, as propostas apresentadas por este devem ser levadas em consideração, independentemente do cargo ou do tempo de trabalho na organização;
  - **Honestidade**: deve permear toda a equipe. O engenheiro de software deve estar consciente do seu nível técnico e ser honesto com os demais membros da equipe, não supervalorizando ou subvalorizando as suas habilidades;
  - **Respeito**: essencial em uma equipe multidisciplinar, na qual cada profissional deve ter consciência das diferenças do outro na maneira de pensar e de trabalhar, sem atribuir conclusões precipitadas em relação à competência deste em realizar as atividades do projeto.

## Planejamento e processo de software

### Estrutura básica do desenvolvimento de software

- Todo modelo de desenvolvimento de software, seja tradicional ou ágil, segue uma metodologia genérica composta de cinco etapas: comunicação, planejamento, modelagem, construção e entrega (PRESSMAN; MAXIM, 2016);
- **Comunicação**: é realizado o contato com as partes interessadas para tratar de procedimentos do início do projeto (contratos, termos de abertura, dentre outros) e levantamento dos requisitos funcionais (relacionados à funcionalidade do sistema) e não funcionais (relacionados à segurança e às configurações do sistema);
- **Planejamento**: é definido o cronograma de atividades dos profissionais envolvidos, as estimativas de utilização de recursos (humanos, materiais, financeiros e tecnológicos) e como será realizado o acompanhamento do projeto (a definição de métricas de desempenho, por exemplo);
- **Modelagem**: também conhecida como implementação e teste unitário, são realizadas as atividades de desenvolvimento do software propriamente dito. É nessa fase que o projeto do software começa a ganhar forma, com os primeiros diagramas e fluxogramas (diagramas UML, por exemplo);
- **Construção**: os requisitos são traduzidos em linhas de código, as quais formam os programas componentes do conjunto de software;
- **Entrega**: o cliente deverá testar o software e verificar se os requisitos foram atendidos;
- Essas cinco etapas dizem respeito à estrutura básica de desenvolvimento de um software; ela é aplicada, de modo direto ou com adaptações, nos modelos tradicionais e ágeis.

### Modelos tradicionais de desenvolvimento

- **Modelo em cascata**:
  - É o modelo mais antigo de desenvolvimento em engenharia de software;
  - De acordo com Sommerville (2011, p. 20), é "um processo dirigido a planos – em princípio, você deve planejar e programar todas as atividades do processo antes de começar a trabalhar nelas" (SOMMERVILLE, 2011, p. 20);
  - Nesse modelo, a estrutura básica de desenvolvimento é aplicada de modo sequencial, ou seja, com uma atividade precedendo a outra;
  - Para passar de uma atividade a outra, é necessária a aprovação do responsável pelo desenvolvimento, geralmente por meio de um documento assinado;
  - Nenhuma atividade pode ser iniciada até que a anterior esteja concluída, e o software é colocado em uso somente na etapa final (entrega);
  - O modelo em cascata é adequado para ambientes de desenvolvimento estável, com pouca ou nenhuma alteração de requisitos, pois se trata de um modelo inflexível.
- **Modelo em espiral**:
  - As etapas de comunicação, planejamento, modelagem, construção e entrega se repetem com sucessivas versões cada vez mais sofisticadas do sistema;
  - À medida que se efetua cada entrega, uma nova fase de comunicação se inicia por meio da revisão dos requisitos, sucedendo para uma nova sessão de planejamento, modelagem etc;
  - Esse modelo, em espiral, é adequado para o desenvolvimento de software em larga escala e para ambientes com mais incerteza em relação aos requisitos, uma vez que permite a revisão desses sempre que uma nova entrega é efetuada;
  - É adequado para software de desenvolvimento contínuo, no qual novas versões podem ser lançadas a cada entrega.
- **Modelo em V**:
  - Esse modelo é uma variação dos modelos em cascata e espiral;
  - Esse modelo divide o processo de desenvolvimento em duas macroetapas mutuamente relacionadas, uma de projeto e codificação, e outra de testes, visando à garantia da qualidade do software;
    - Na primeira etapa é realizada a modelagem de requisitos do sistema; depois efetua-se o projeto de arquitetura do sistema como um todo e, ainda, dos seus componentes, partindo para o fim da etapa, em que se gera o código do programa conforme a arquitetura planejada;
    - Na segunda etapa realizam-se os testes para validar as atividades realizadas na macroetapa anterior. Dessa forma, há primeiramente os testes dos códigos desenvolvidos; em seguida, acontecem os testes de integração da arquitetura do sistema e de seus componentes, partindo para o teste do sistema como um todo e, finalmente, para o teste de aceitação por parte do cliente, tendo como base os requisitos definidos para o programa.
  - O modelo em V é indicado quando a realização de múltiplos testes seja necessária, pois possibilita melhor detecção de erros em cada etapa de realização;
- **Modelo cíclico**:
  - Esse modelo tem formato cíclico, como o de espiral, porém enfatiza a rápida execução das etapas de planejamento e modelagem, adicionando uma etapa de construção de protótipos;
  - Assim como os demais modelos, o de prototipação inicia-se com a etapa de comunicação, a qual é uma das mais importantes;
  - Nessa fase, uma reunião é feita com as partes interessadas no projeto (clientes, desenvolvedores, dentre outras) para definir os objetivos e os requisitos necessários para o desenvolvimento do software;
  - Em seguida, as etapas de planejamento e modelagem são executadas no formato de um projeto rápido, em que se constrói um protótipo do software;
  - Depois de entregue o software e recebido o feedback, o protótipo é discutido em uma nova etapa de comunicação, na qual os requisitos do projeto são refinados, e assim sucessivamente.
- **Modelo RUP**:
  - O modelo RUP (Rational Unified Process), também conhecido como Processo Unificado (PU), "reúne elementos de todos os modelos de processo genéricos, ilustra boas práticas de especificação e no projeto e apoia a prototipação e a entrega incremental" (SOMMERVILLE, 2011, p. 34);
  - A organização do RUP acontece em quatro fases:
    - Na fase de concepção, realizam-se a comunicação e o planejamento com o cliente, tendo como objetivo estabelecer um estudo de caso para o negócio a ser desenvolvido;
    - Na segunda fase, a de elaboração, realiza-se a modelagem de uma arquitetura do sistema;
    - Na fase de construção, efetuam-se a construção ou codificação do sistema e os testes de unidades para cada componente desse sistema;
    - Na fase de transição, efetua-se a entrega do sistema ao cliente e coloca-se esse sistema para funcionar em um ambiente real;
  - Esse modelo é recomendado para projetos em que a estabilidade dos processos de desenvolvimento seja importante, já que o modelo sendo estruturado, ao ser aplicado, tende a reduzir os riscos de desenvolvimento de software;

### Modelos ágeis de desenvolvimento

- Os modelos ágeis têm origem em princípios estabelecidos pelo Manifesto para o Desenvolvimento Ágil de Software, desenvolvido por Kent Beck – criador do modelo XP (Extreme Programming) – e mais 16 desenvolvedores;
- De acordo com esse manifesto, no processo de desenvolvimento de software é importante valorizar os seguintes aspectos: as interações entre os indivíduos acima de processos e sistemas; o software operacional acima da documentação completa; a colaboração com os clientes acima de negociação contratual; e as respostas às mudanças acima de seguir um plano;
- **Modelo XP**:
  - É um modelo ágil que considera o desenvolvimento de software sob uma perspectiva diferente dos demais modelos;
  - Para essa metodologia, a definição de requisitos é feita considerando cenários ou histórias de clientes; os programadores trabalham sempre em pares e o código é escrito em definitivo apenas após a realização de testes;
  - O projeto na XP segue o princípio KISS (Keep It Simple Stupid); sendo assim, é melhor um projeto simples com múltiplos incrementos posteriores do que projetos mais complexos logo de início;
  - Desse modo, quando concluído, cada projeto é integrado ao sistema e todos os testes, após essa integração, devem apresentar sucesso.
- **Modelo Scrum**:
  - Esse modelo tem caráter cíclico, cujo nome diz respeito a uma jogada no esporte rugby, na qual os atletas se encontram corpo a corpo;
  - Nesse modelo, as atividades de desenvolvimento ocorrem em um ciclo denominado _sprint_;
  - O ciclo de trabalho no scrum consiste na realização de tarefas de desenvolvimento, definidas em uma lista de prioridades de requisitos, chamada de _backlog_;
  - É realizada uma reunião inicial, denominada _sprint planning meeting_, em que são feitas as definições de planejamento das atividades que serão desenvolvidas;
  - Após a realização das sprints, a equipe apresenta as funcionalidades do software implantadas e, então, um novo ciclo de desenvolvimento se inicia.
- **Modelo AUP**:
  - Trata-se de uma variante do Processo Unificado voltada para o desenvolvimento ágil;
  - Esse processo adota as atividades clássicas do RUP – concepção, elaboração, construção e transição –, porém com ciclos repetitivos para tornar o modelo mais ágil.
  - Cada iteração adota as seguintes atividades:
    1. Modelagem: elaboração de modelos, preferencialmente com o uso da UML (Unified Modeling Language);
    2. Implementação: transformação dos modelos em código;
    3. Testes: realização de testes para a descoberta de erros e oportunidades de melhoria no código;
    4. Entrega: entrega de um incremento do código e feedback dos usuários;
    5. Configuração e gerenciamento do projeto: gerenciamento de configurações, alterações, riscos e controle;
    6. Gerenciamento do ambiente: gerenciamento de processos, padrões, ferramentas e tecnologias de suporte.

## Engenharia de requisitos

### Métodos para a coleta de requisitos

- Segundo Paula Filho (2009), os requisitos de um software devem atender a determinadas características:
  - **Correção**: prevê que o requisito do software seja corretamente descrito e que ele seja realmente o do software a ser construído;
  - **Precisão**: trata da descrição do requisito, não permitindo interpretações ambíguas em relação ao que deve ser feito;
  - **Completeza**: diz respeito ao requisito abranger, de modo completo, aspectos relativos a funcionalidade, desempenho, interfaces, restrições e aspectos de qualidade, sem cláusulas de pendências;
  - **Consistência**: possibilita que o requisito não apresente conflitos com outros requisitos, de modo lógico ou temporal;
  - **Priorização**: caracteriza-se pelo requisito poder ser classificado, em conjunto com outros requisitos, conforme sua importância (essencial, desejável ou opcional, por exemplo);
  - **Verificabilidade**: trata do requisito ser verificável quanto à sua conformidade com o produto final desenvolvido;
  - **Modificabilidade**: permite que o requisito seja modificável quando necessário;
  - **Rastreabilidade**: diz respeito ao requisito poder ser rastreável quanto aos seus antecedentes e consequências, podendo ser relacionada à origem do requisito (para trás) ou aos resultados obtidos (para frente).
- Fases da engenharia de requisitos:
  - **Concepção**: são previstos os problemas que serão solucionados pelo software e são identificadas as partes interessadas;
  - **Levantamento**: informações necessárias para a elaboração dos requisitos, que acontece por meio de técnicas, como entrevistas e etnografia, aplicadas junto às partes interessadas;
  - **Elaboração**: informações obtidas são analisadas, o que permite descrever como os usuários interagirão com o sistema e, assim, construir um modelo de requisitos para ser apresentado;
  - **Negociação**: são discutidos possíveis conflitos relacionados ao que as partes interessadas desejam e ao que pode ser desenvolvido até se chegar a um consenso;
  - **Especificação**: ou SRS (Software Requirements Specification) –, documento contendo a descrição detalhada dos requisitos do sistema a ser desenvolvido;
  - **Validação**: detecção e corrição prováveis inconsistências, omissões e erros;
  - **Gestão**: uma vez validada, a especificação de requisitos de software é acompanhada durante o processo de desenvolvimento de modo que, caso necessário, correções e mudanças possam ser feitas.
- Entrevistas:
  - A entrevista é uma das técnicas primárias para a descoberta de requisitos;
  - Em um ambiente formal, ou informal, realizam-se perguntas para saber a opinião das partes interessadas sobre quais seriam os requisitos do sistema para o usuário;
  - As entrevistas podem ser de dois tipos, abertas ou fechadas:
    - Abertas: não há um roteiro definido de perguntas – inicia-se com uma pergunta inicial e a entrevista evolui conforme as respostas dos _stakeholders_;
    - Fechadas: as perguntas são previamente definidas e os stakeholders se atêm apenas a responder às perguntas realizadas.
- Análise de cenários:
  - Segundo Sommerville (2011, p. 73), "as pessoas geralmente acham mais fácil se relacionar com exemplos da vida real do que com descrições abstratas. Elas podem compreender e criticar um cenário de como elas podem interagir com um sistema de software";
  - Essa técnica, conforme o nome sugere, está relacionada à montagem e simulação de cenários hipotéticos para a utilização do software, como a criação de histórias no método Extreme Programming;
  - Elementos básicos para a análise de cenários:
    - Suposição inicial: expõe-se a situação na qual o software será utilizado, o cenário-base;
    - Situação normal de utilização: descreve-se o processo de utilização do software, passo a passo, considerando o papel de cada usuário nesse processo;
    - O que pode dar errado: descreve-se, a partir da situação normal de utilização, os possíveis erros que podem acontecer durante a utilização do software;
    - Outras atividades: verificam-se outras atividades ou restrições com relação ao uso do software, as quais não se encontram na situação normal de utilização;
    - Estado do sistema na conclusão: abordam-se os processos relativos à finalização do uso do sistema e como a sua utilização é concluída.
- Etnografia:
  - Essa possível técnica para o levantamento de requisitos considera que o uso do software é realizado em um contexto social e organizacional, ou seja, é considerado parte de uma cultura;
  - A etnografia consiste na observação do uso de um artefato em seu ambiente pelos usuários;
  - Um observador se introduz nesse ambiente e realiza anotações a respeito do uso desse software – da forma como o sistema é utilizado, o porquê de determinadas funcionalidades serem usadas ou não e as interações dos usuários com a interface do sistema.
- Coleta colaborativa:
  - A coleta colaborativa de requisitos é uma técnica em que se realizam reuniões com a participação das partes interessadas e dos engenheiros de software;
  - Nessas reuniões, identificam-se os problemas, propõem-se as soluções e definem-se diferentes abordagens para definir um conjunto preliminar de requisitos.

### Classificação de requisitos

- Classificação de requisitos de acordo com Pfleeger (2004):
  - **Totalmente satisfeitos**: pode-se citar as funcionalidades básicas de um sistema, por exemplo, um sistema comercial deve possibilitar a emissão de notas fiscais;
  - **Desejáveis**: dizem respeito a funcionalidades acessórias que seriam muito úteis para o usuário desempenhar suas tarefas, mas que podem ser dispensadas em uma versão básica do sistema;
  - **Possíveis**: dizem respeito a adições ao sistema que podem ser consideradas em determinado momento, porém podem ser dispensadas se necessário.
- Classificação de requisitos de acordo com Pressman (2011):
  - **Normais**: são estabelecidos com base em objetivos e metas definidos junto às partes interessadas, utilizando técnicas de levantamento de requisitos;
  - **Esperados**: que nem sempre são declarados pelas partes interessadas, podem ser tão fundamentais quanto os requisitos normais, e sua ausência causará insatisfações;
  - **Fascinantes**: caso estiverem presentes, ocasionarão, além das expectativas das partes interessadas, extrema satisfação, constituindo-se em uma surpresa.
- Requisitos com base na funcionalidade:
  - **Funcionais**: funcionalidades básicas de determinado sistema, descrevendo o que este deverá executar em cada situação. O cumprimento desses requisitos garante que o sistema funcione conforme o esperado;
  - **Não funcionais**: restrições do sistema, ou seja, não descrevem o que o sistema deverá executar, mas sim como ele se comportará durante a execução.
- Requisitos conforme os componentes do sistema e seus processos de desenvolvimento, Pfleeger (2004):
  - **Requisitos de ambiente físico**: dizem respeito ao local físico de instalação e funcionamento do sistema ou hardware, bem como possíveis restrições de funcionamento, como temperatura, ruídos, vibrações, interferência magnética, dentre outras;
  - **Requisitos de interface**: tratam da interação de um sistema com outros sistemas, abrangendo aspectos como a formatação de dados, entradas e saídas, dentre outros;
  - **Requisitos de usuários e fatores humanos**: abrangem a forma com a qual o usuário interage com o sistema e sua interface, e consideram diferentes níveis de competências, conhecimentos, habilidades e atitudes, bem como a necessidade de treinamento para o seu melhoramento;
  - **Requisitos de funcionalidade**: dizem respeito às funções do sistema, seus modos de operação, necessidades de aprimoramento e limitações;
  - **Requisitos de documentação**: tratam da necessidade de documentação para o sistema, bem como do formato, se é on-line, em papel (físico) ou ambos;
  - **Requisitos de dados**: tratam da formatação dos dados, da frequência de envio e recebimento, da precisão, do fluxo e da forma de armazenagem e manutenção desses dados no sistema;
  - **Requisitos de recursos**: dizem respeito a materiais, pessoas, tecnologias, dentre outros, necessários para o adequado funcionamento do sistema;
  - **Requisitos de segurança**: dizem respeito às políticas de acesso ao sistema, bem como à gestão de dados e informações, principalmente, dos usuários e demais _stakeholders_;
  - **Requisitos de garantia da qualidade**: abrangem, por sua vez, questões básicas de qualidade do sistema, como confiabilidade, disponibilidade, manutenibilidade, capacidade, prevenção a falhas e defeitos, correção de erros, indicadores de desempenho, dentre outros.
