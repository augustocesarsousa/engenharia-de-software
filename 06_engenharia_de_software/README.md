# Engenharia de Software

## Introdução à engenharia de software

### Quem é o engenheiro de software

- O engenheiro de software é o profissional responsável pelo desenvolvimento e pela implantação de produtos, serviços e sistemas de software, desde a ideia inicial até o produto final;
- De acordo com o IEEE (Institute of Electrical and Electronic Engineers) – entidade internacional que definiu as diretrizes dessa área – engenharia de software trata-se da “aplicação de uma abordagem sistemática, disciplinada e quantificável no desenvolvimento, na operação e na manutenção de software, isto é, a aplicação de engenharia ao software” (IEEE apud PRESSMAN; MAXIM, 2016);
- Assim que se gradua, um engenheiro de software deve ser capaz de coordenar projetos, administrar equipes de trabalho e, inclusive, gerenciar conflitos que podem surgir durante o processo de desenvolvimento;
- O engenheiro de software deve, portanto, "fornecer aos desenvolvedores (inclusive gerentes, analistas e designers) as ferramentas e processos que deverão ser usados e será o responsável por verificar se esse uso está sendo feito efetivamente e de forma otimizada" (WAZLAWICK, 2013, p. 19);
- Existem diferenças entre as áreas de engenharia de software, engenharia da computação e ciência da computação:
  - O engenheiro de software atua em projeto, desenvolvimento e implantação de software;
  - O engenheiro da computação se volta ao desenvolvimento de hardware, como computadores e equipamentos eletrônicos;
  - O cientista da computação, por sua vez, desenvolve os modelos matemáticos, os algoritmos e as demais ferramentas teóricas que serão utilizados pelo engenheiro de software, o qual é, portanto, o elo de ligação entre os demais profissionais de TI;
- Conforme dados da ABES (Associação Brasileira de Empresas de Software), o Brasil está em 1º lugar na América Latina em investimentos na área de software, e em 9º lugar mundialmente;
- O engenheiro de software é o responsável pela gestão consciente de recursos humanos, de materiais financeiros e tecnológicos necessários para o desenvolvimento do software e de processos de desenvolvimento, desde a coleta de requisitos até a entrega do software em sua versão final;
- A atividade do engenheiro de software está sendo regulamentada pela Resolução n. 1.100 do CONFEA (Conselho Federal de Engenharia e Agronomia), a qual defende que esse profissional integra o grupo dos engenheiros eletricistas, tendo direitos e deveres de um engenheiro conforme a legislação em vigor (CONFEA, 2018).

### A prática da engenharia de software

- O engenheiro de software é um profissional de inovação e um projetista;
- A inovação em engenharia de software pode acontecer de diferentes formas:
  - A primeira, mais frequente, é denominada **inovação incremental** ou melhoria contínua;
  - A segunda, denominada **inovação radical**, consiste na criação de algo totalmente novo, do "zero".
- Métodos do desenvolvimento de software:
  - **Engenharia de requisitos**: consiste na definição, com a participação do cliente ou usuário, do que o software necessita ter em termos de funcionalidade, requisitos de segurança, aparência das telas, botões, menus, compatibilidade com sistemas operacionais específicos, dentre outros;
  - **Planejamento**: é a fase criativa do desenvolvimento de software. Envolve definir a sua arquitetura; criar esboços das telas; definir os diagramas básicos (diagramas de classes e atividades, por exemplo) e as linguagens de programação a serem utilizadas para cada funcionalidade do software;
  - **Desenvolvimento ou codificação do software**: é a fase de desenvolvimento do software, durante o processo de desenvolvimento, podem surgir incidentes ou problemas, forçando o projeto a ser modificado, ou erros podem passar despercebidos e somente aparecer quando o software estiver concluído;
  - **Fase de testes**: após desenvolvido e codificado, o software deve ser testado – atividade que deve ser repetida sempre que necessária. Isso se deve porque erros – mais conhecidos como bugs – podem custar caro, principalmente se o software já estiver em fase de lançamento;
  - **Manutenção e melhorias**: após o software ser desenvolvido e lançado, é necessária a realização de manutenção e melhorias contínuas.
- Além dos cinco métodos descritos, é importante ressaltar que, como em toda profissão, a prática de engenharia de software deve se ater a princípios éticos, de modo que os resultados do trabalho do profissional não prejudiquem a si e a organização ou o cliente.

### O engenheiro de software e outros profissionais

- Em uma organização, o engenheiro de software pode assumir várias funções, atuando no desenvolvimento de software, na gestão de equipes ou mesmo como consultor;
- O engenheiro de software é um profissional que trabalha com equipes de diferentes áreas do conhecimento;
- Constantine (1993 apud PRESSMAN; MAXIM, 2016) enumera paradigmas, ou padrões, para a formação de equipes de desenvolvimento:
  - **Paradigma fechado**: a principal característica é a existência de uma hierarquia formal entre gestores e colaboradores, em que se predomina a ordem. Porém, essa estrutura pode não ser ideal quando se necessita desenvolver a criatividade e a inovação nas equipes de trabalho, uma vez que a comunicação entre os membros, nesse paradigma, tende a ser mais restrita;
  - **Paradigma randômico**: o que predomina é a iniciativa individual dos membros da equipe. Opostamente ao paradigma fechado, esse é mais adequado para o desenvolvimento de inovações. Porém, por depender de decisões individuais, podem surgir conflitos, caso seja preciso agir de modo mais ordenado, uma vez que nesse paradigma a possibilidade de surgirem divergências de opiniões é maior;
  - **Paradigma sincronizado**: o problema é segmentado de modo que os membros da equipe organizem-se para que cada um trabalhe em uma parte. Porém, a comunicação entre os membros, nesse caso, é prejudicada, uma vez que cada equipe, desenvolvendo apenas uma parte do software, terá conhecimento somente da parte que desenvolve, tendo pouco ou nenhum conhecimento das demais partes;
  - **Paradigma aberto**: predominam-se a colaboração, a comunicação e o consenso nas decisões. Para projetos inovadores e mais complexos, equipes estruturadas nesse paradigma tendem a se destacar;
- Sommerville (2011) enumera quatro fatores essenciais no gerenciamento de equipes:
  - **Consistência**: diz respeito à valorização por igual de cada membro da equipe, considerando que as pessoas não devem sentir que seu trabalho é desvalorizado ou subvalorizado;
  - **Inclusão**: é derivada da consistência. Uma vez que o trabalho de um profissional deve ser valorizado, as propostas apresentadas por este devem ser levadas em consideração, independentemente do cargo ou do tempo de trabalho na organização;
  - **Honestidade**: deve permear toda a equipe. O engenheiro de software deve estar consciente do seu nível técnico e ser honesto com os demais membros da equipe, não supervalorizando ou subvalorizando as suas habilidades;
  - **Respeito**: essencial em uma equipe multidisciplinar, na qual cada profissional deve ter consciência das diferenças do outro na maneira de pensar e de trabalhar, sem atribuir conclusões precipitadas em relação à competência deste em realizar as atividades do projeto.

## Planejamento e processo de software

### Estrutura básica do desenvolvimento de software

- Todo modelo de desenvolvimento de software, seja tradicional ou ágil, segue uma metodologia genérica composta de cinco etapas: comunicação, planejamento, modelagem, construção e entrega (PRESSMAN; MAXIM, 2016);
- **Comunicação**: é realizado o contato com as partes interessadas para tratar de procedimentos do início do projeto (contratos, termos de abertura, dentre outros) e levantamento dos requisitos funcionais (relacionados à funcionalidade do sistema) e não funcionais (relacionados à segurança e às configurações do sistema);
- **Planejamento**: é definido o cronograma de atividades dos profissionais envolvidos, as estimativas de utilização de recursos (humanos, materiais, financeiros e tecnológicos) e como será realizado o acompanhamento do projeto (a definição de métricas de desempenho, por exemplo);
- **Modelagem**: também conhecida como implementação e teste unitário, são realizadas as atividades de desenvolvimento do software propriamente dito. É nessa fase que o projeto do software começa a ganhar forma, com os primeiros diagramas e fluxogramas (diagramas UML, por exemplo);
- **Construção**: os requisitos são traduzidos em linhas de código, as quais formam os programas componentes do conjunto de software;
- **Entrega**: o cliente deverá testar o software e verificar se os requisitos foram atendidos;
- Essas cinco etapas dizem respeito à estrutura básica de desenvolvimento de um software; ela é aplicada, de modo direto ou com adaptações, nos modelos tradicionais e ágeis.

### Modelos tradicionais de desenvolvimento

- **Modelo em cascata**:
  - É o modelo mais antigo de desenvolvimento em engenharia de software;
  - De acordo com Sommerville (2011, p. 20), é "um processo dirigido a planos – em princípio, você deve planejar e programar todas as atividades do processo antes de começar a trabalhar nelas" (SOMMERVILLE, 2011, p. 20);
  - Nesse modelo, a estrutura básica de desenvolvimento é aplicada de modo sequencial, ou seja, com uma atividade precedendo a outra;
  - Para passar de uma atividade a outra, é necessária a aprovação do responsável pelo desenvolvimento, geralmente por meio de um documento assinado;
  - Nenhuma atividade pode ser iniciada até que a anterior esteja concluída, e o software é colocado em uso somente na etapa final (entrega);
  - O modelo em cascata é adequado para ambientes de desenvolvimento estável, com pouca ou nenhuma alteração de requisitos, pois se trata de um modelo inflexível.
- **Modelo em espiral**:
  - As etapas de comunicação, planejamento, modelagem, construção e entrega se repetem com sucessivas versões cada vez mais sofisticadas do sistema;
  - À medida que se efetua cada entrega, uma nova fase de comunicação se inicia por meio da revisão dos requisitos, sucedendo para uma nova sessão de planejamento, modelagem etc;
  - Esse modelo, em espiral, é adequado para o desenvolvimento de software em larga escala e para ambientes com mais incerteza em relação aos requisitos, uma vez que permite a revisão desses sempre que uma nova entrega é efetuada;
  - É adequado para software de desenvolvimento contínuo, no qual novas versões podem ser lançadas a cada entrega.
- **Modelo em V**:
  - Esse modelo é uma variação dos modelos em cascata e espiral;
  - Esse modelo divide o processo de desenvolvimento em duas macroetapas mutuamente relacionadas, uma de projeto e codificação, e outra de testes, visando à garantia da qualidade do software;
    - Na primeira etapa é realizada a modelagem de requisitos do sistema; depois efetua-se o projeto de arquitetura do sistema como um todo e, ainda, dos seus componentes, partindo para o fim da etapa, em que se gera o código do programa conforme a arquitetura planejada;
    - Na segunda etapa realizam-se os testes para validar as atividades realizadas na macroetapa anterior. Dessa forma, há primeiramente os testes dos códigos desenvolvidos; em seguida, acontecem os testes de integração da arquitetura do sistema e de seus componentes, partindo para o teste do sistema como um todo e, finalmente, para o teste de aceitação por parte do cliente, tendo como base os requisitos definidos para o programa.
  - O modelo em V é indicado quando a realização de múltiplos testes seja necessária, pois possibilita melhor detecção de erros em cada etapa de realização;
- **Modelo cíclico**:
  - Esse modelo tem formato cíclico, como o de espiral, porém enfatiza a rápida execução das etapas de planejamento e modelagem, adicionando uma etapa de construção de protótipos;
  - Assim como os demais modelos, o de prototipação inicia-se com a etapa de comunicação, a qual é uma das mais importantes;
  - Nessa fase, uma reunião é feita com as partes interessadas no projeto (clientes, desenvolvedores, dentre outras) para definir os objetivos e os requisitos necessários para o desenvolvimento do software;
  - Em seguida, as etapas de planejamento e modelagem são executadas no formato de um projeto rápido, em que se constrói um protótipo do software;
  - Depois de entregue o software e recebido o feedback, o protótipo é discutido em uma nova etapa de comunicação, na qual os requisitos do projeto são refinados, e assim sucessivamente.
- **Modelo RUP**:
  - O modelo RUP (Rational Unified Process), também conhecido como Processo Unificado (PU), "reúne elementos de todos os modelos de processo genéricos, ilustra boas práticas de especificação e no projeto e apoia a prototipação e a entrega incremental" (SOMMERVILLE, 2011, p. 34);
  - A organização do RUP acontece em quatro fases:
    - Na fase de concepção, realizam-se a comunicação e o planejamento com o cliente, tendo como objetivo estabelecer um estudo de caso para o negócio a ser desenvolvido;
    - Na segunda fase, a de elaboração, realiza-se a modelagem de uma arquitetura do sistema;
    - Na fase de construção, efetuam-se a construção ou codificação do sistema e os testes de unidades para cada componente desse sistema;
    - Na fase de transição, efetua-se a entrega do sistema ao cliente e coloca-se esse sistema para funcionar em um ambiente real;
  - Esse modelo é recomendado para projetos em que a estabilidade dos processos de desenvolvimento seja importante, já que o modelo sendo estruturado, ao ser aplicado, tende a reduzir os riscos de desenvolvimento de software;

### Modelos ágeis de desenvolvimento

- Os modelos ágeis têm origem em princípios estabelecidos pelo Manifesto para o Desenvolvimento Ágil de Software, desenvolvido por Kent Beck – criador do modelo XP (Extreme Programming) – e mais 16 desenvolvedores;
- De acordo com esse manifesto, no processo de desenvolvimento de software é importante valorizar os seguintes aspectos: as interações entre os indivíduos acima de processos e sistemas; o software operacional acima da documentação completa; a colaboração com os clientes acima de negociação contratual; e as respostas às mudanças acima de seguir um plano;
- **Modelo XP**:
  - É um modelo ágil que considera o desenvolvimento de software sob uma perspectiva diferente dos demais modelos;
  - Para essa metodologia, a definição de requisitos é feita considerando cenários ou histórias de clientes; os programadores trabalham sempre em pares e o código é escrito em definitivo apenas após a realização de testes;
  - O projeto na XP segue o princípio KISS (Keep It Simple Stupid); sendo assim, é melhor um projeto simples com múltiplos incrementos posteriores do que projetos mais complexos logo de início;
  - Desse modo, quando concluído, cada projeto é integrado ao sistema e todos os testes, após essa integração, devem apresentar sucesso.
- **Modelo Scrum**:
  - Esse modelo tem caráter cíclico, cujo nome diz respeito a uma jogada no esporte rugby, na qual os atletas se encontram corpo a corpo;
  - Nesse modelo, as atividades de desenvolvimento ocorrem em um ciclo denominado _sprint_;
  - O ciclo de trabalho no scrum consiste na realização de tarefas de desenvolvimento, definidas em uma lista de prioridades de requisitos, chamada de _backlog_;
  - É realizada uma reunião inicial, denominada _sprint planning meeting_, em que são feitas as definições de planejamento das atividades que serão desenvolvidas;
  - Após a realização das sprints, a equipe apresenta as funcionalidades do software implantadas e, então, um novo ciclo de desenvolvimento se inicia.
- **Modelo AUP**:
  - Trata-se de uma variante do Processo Unificado voltada para o desenvolvimento ágil;
  - Esse processo adota as atividades clássicas do RUP – concepção, elaboração, construção e transição –, porém com ciclos repetitivos para tornar o modelo mais ágil.
  - Cada iteração adota as seguintes atividades:
    1. Modelagem: elaboração de modelos, preferencialmente com o uso da UML (Unified Modeling Language);
    2. Implementação: transformação dos modelos em código;
    3. Testes: realização de testes para a descoberta de erros e oportunidades de melhoria no código;
    4. Entrega: entrega de um incremento do código e feedback dos usuários;
    5. Configuração e gerenciamento do projeto: gerenciamento de configurações, alterações, riscos e controle;
    6. Gerenciamento do ambiente: gerenciamento de processos, padrões, ferramentas e tecnologias de suporte.

## Engenharia de requisitos

### Métodos para a coleta de requisitos

- Segundo Paula Filho (2009), os requisitos de um software devem atender a determinadas características:
  - **Correção**: prevê que o requisito do software seja corretamente descrito e que ele seja realmente o do software a ser construído;
  - **Precisão**: trata da descrição do requisito, não permitindo interpretações ambíguas em relação ao que deve ser feito;
  - **Completeza**: diz respeito ao requisito abranger, de modo completo, aspectos relativos a funcionalidade, desempenho, interfaces, restrições e aspectos de qualidade, sem cláusulas de pendências;
  - **Consistência**: possibilita que o requisito não apresente conflitos com outros requisitos, de modo lógico ou temporal;
  - **Priorização**: caracteriza-se pelo requisito poder ser classificado, em conjunto com outros requisitos, conforme sua importância (essencial, desejável ou opcional, por exemplo);
  - **Verificabilidade**: trata do requisito ser verificável quanto à sua conformidade com o produto final desenvolvido;
  - **Modificabilidade**: permite que o requisito seja modificável quando necessário;
  - **Rastreabilidade**: diz respeito ao requisito poder ser rastreável quanto aos seus antecedentes e consequências, podendo ser relacionada à origem do requisito (para trás) ou aos resultados obtidos (para frente).
- Fases da engenharia de requisitos:
  - **Concepção**: são previstos os problemas que serão solucionados pelo software e são identificadas as partes interessadas;
  - **Levantamento**: informações necessárias para a elaboração dos requisitos, que acontece por meio de técnicas, como entrevistas e etnografia, aplicadas junto às partes interessadas;
  - **Elaboração**: informações obtidas são analisadas, o que permite descrever como os usuários interagirão com o sistema e, assim, construir um modelo de requisitos para ser apresentado;
  - **Negociação**: são discutidos possíveis conflitos relacionados ao que as partes interessadas desejam e ao que pode ser desenvolvido até se chegar a um consenso;
  - **Especificação**: ou SRS (Software Requirements Specification) –, documento contendo a descrição detalhada dos requisitos do sistema a ser desenvolvido;
  - **Validação**: detecção e corrição prováveis inconsistências, omissões e erros;
  - **Gestão**: uma vez validada, a especificação de requisitos de software é acompanhada durante o processo de desenvolvimento de modo que, caso necessário, correções e mudanças possam ser feitas.
- Entrevistas:
  - A entrevista é uma das técnicas primárias para a descoberta de requisitos;
  - Em um ambiente formal, ou informal, realizam-se perguntas para saber a opinião das partes interessadas sobre quais seriam os requisitos do sistema para o usuário;
  - As entrevistas podem ser de dois tipos, abertas ou fechadas:
    - Abertas: não há um roteiro definido de perguntas – inicia-se com uma pergunta inicial e a entrevista evolui conforme as respostas dos _stakeholders_;
    - Fechadas: as perguntas são previamente definidas e os stakeholders se atêm apenas a responder às perguntas realizadas.
- Análise de cenários:
  - Segundo Sommerville (2011, p. 73), "as pessoas geralmente acham mais fácil se relacionar com exemplos da vida real do que com descrições abstratas. Elas podem compreender e criticar um cenário de como elas podem interagir com um sistema de software";
  - Essa técnica, conforme o nome sugere, está relacionada à montagem e simulação de cenários hipotéticos para a utilização do software, como a criação de histórias no método Extreme Programming;
  - Elementos básicos para a análise de cenários:
    - Suposição inicial: expõe-se a situação na qual o software será utilizado, o cenário-base;
    - Situação normal de utilização: descreve-se o processo de utilização do software, passo a passo, considerando o papel de cada usuário nesse processo;
    - O que pode dar errado: descreve-se, a partir da situação normal de utilização, os possíveis erros que podem acontecer durante a utilização do software;
    - Outras atividades: verificam-se outras atividades ou restrições com relação ao uso do software, as quais não se encontram na situação normal de utilização;
    - Estado do sistema na conclusão: abordam-se os processos relativos à finalização do uso do sistema e como a sua utilização é concluída.
- Etnografia:
  - Essa possível técnica para o levantamento de requisitos considera que o uso do software é realizado em um contexto social e organizacional, ou seja, é considerado parte de uma cultura;
  - A etnografia consiste na observação do uso de um artefato em seu ambiente pelos usuários;
  - Um observador se introduz nesse ambiente e realiza anotações a respeito do uso desse software – da forma como o sistema é utilizado, o porquê de determinadas funcionalidades serem usadas ou não e as interações dos usuários com a interface do sistema.
- Coleta colaborativa:
  - A coleta colaborativa de requisitos é uma técnica em que se realizam reuniões com a participação das partes interessadas e dos engenheiros de software;
  - Nessas reuniões, identificam-se os problemas, propõem-se as soluções e definem-se diferentes abordagens para definir um conjunto preliminar de requisitos.

### Classificação de requisitos

- Classificação de requisitos de acordo com Pfleeger (2004):
  - **Totalmente satisfeitos**: pode-se citar as funcionalidades básicas de um sistema, por exemplo, um sistema comercial deve possibilitar a emissão de notas fiscais;
  - **Desejáveis**: dizem respeito a funcionalidades acessórias que seriam muito úteis para o usuário desempenhar suas tarefas, mas que podem ser dispensadas em uma versão básica do sistema;
  - **Possíveis**: dizem respeito a adições ao sistema que podem ser consideradas em determinado momento, porém podem ser dispensadas se necessário.
- Classificação de requisitos de acordo com Pressman (2011):
  - **Normais**: são estabelecidos com base em objetivos e metas definidos junto às partes interessadas, utilizando técnicas de levantamento de requisitos;
  - **Esperados**: que nem sempre são declarados pelas partes interessadas, podem ser tão fundamentais quanto os requisitos normais, e sua ausência causará insatisfações;
  - **Fascinantes**: caso estiverem presentes, ocasionarão, além das expectativas das partes interessadas, extrema satisfação, constituindo-se em uma surpresa.
- Requisitos com base na funcionalidade:
  - **Funcionais**: funcionalidades básicas de determinado sistema, descrevendo o que este deverá executar em cada situação. O cumprimento desses requisitos garante que o sistema funcione conforme o esperado;
  - **Não funcionais**: restrições do sistema, ou seja, não descrevem o que o sistema deverá executar, mas sim como ele se comportará durante a execução.
- Requisitos conforme os componentes do sistema e seus processos de desenvolvimento, Pfleeger (2004):
  - **Requisitos de ambiente físico**: dizem respeito ao local físico de instalação e funcionamento do sistema ou hardware, bem como possíveis restrições de funcionamento, como temperatura, ruídos, vibrações, interferência magnética, dentre outras;
  - **Requisitos de interface**: tratam da interação de um sistema com outros sistemas, abrangendo aspectos como a formatação de dados, entradas e saídas, dentre outros;
  - **Requisitos de usuários e fatores humanos**: abrangem a forma com a qual o usuário interage com o sistema e sua interface, e consideram diferentes níveis de competências, conhecimentos, habilidades e atitudes, bem como a necessidade de treinamento para o seu melhoramento;
  - **Requisitos de funcionalidade**: dizem respeito às funções do sistema, seus modos de operação, necessidades de aprimoramento e limitações;
  - **Requisitos de documentação**: tratam da necessidade de documentação para o sistema, bem como do formato, se é on-line, em papel (físico) ou ambos;
  - **Requisitos de dados**: tratam da formatação dos dados, da frequência de envio e recebimento, da precisão, do fluxo e da forma de armazenagem e manutenção desses dados no sistema;
  - **Requisitos de recursos**: dizem respeito a materiais, pessoas, tecnologias, dentre outros, necessários para o adequado funcionamento do sistema;
  - **Requisitos de segurança**: dizem respeito às políticas de acesso ao sistema, bem como à gestão de dados e informações, principalmente, dos usuários e demais _stakeholders_;
  - **Requisitos de garantia da qualidade**: abrangem, por sua vez, questões básicas de qualidade do sistema, como confiabilidade, disponibilidade, manutenibilidade, capacidade, prevenção a falhas e defeitos, correção de erros, indicadores de desempenho, dentre outros.

### Especificação e apresentação de requisitos

- Uma forma de se documentar os requisitos, tanto do usuário quanto do sistema, é por meio da especificação de requisitos de software (SRS). Esse documento detalha todos os aspectos do software que deverão ser considerados no processo de construção. Pressman (2011) sugere o seguinte conteúdo para esse documento:
  - **Introdução**: apresentam-se o documento, suas convenções, seu público-alvo, sugestões de leitura, o escopo do projeto de software e as referências utilizadas;
  - **Descrição geral**: detalha-se o software a ser desenvolvido, contemplando características, restrições de projeto, ambiente operacional, dentre outros;
  - **Características do sistema**: detalham-se os requisitos funcionais do sistema e suas características essenciais;
  - **Requisitos de interfaces externas**: detalham-se os requisitos referentes às interfaces de usuário, software, hardware e comunicação;
  - **Requisitos não funcionais**: apresentam-se requisitos considerados não funcionais, como de desempenho, segurança, proteção e qualidade;
  - **Outros requisitos**: descrevem-se requisitos não mencionados nos itens anteriores, porém, importantes para o projeto.
- As especificação de requisitos pode ser feita de diferentes formas. Sommerville (2011) descreve algumas:
  - **Sentenças em linguagem natural**: os requisitos são escritos na linguagem natural – sugere-se uma frase para expressar cada requisito;
  - **Linguagem natural estruturada**: descrevem-se os requisitos em linguagem natural, porém em um formulário estruturado (template);
  - **Linguagem de descrição de projeto**: os requisitos são escritos com o uso de uma linguagem similar à de programação, mas com características mais abstratas;
  - **Notações gráficas**: utilizam-se notações gráficas para a descrição dos requisitos, como a linguagem UML;
  - **Especificações matemáticas**: utilizam-se notações matemáticas para a expressão dos requisitos (conjuntos, por exemplo) – deve-se observar que a maioria das pessoas pode não compreender os requisitos escritos dessa maneira.

## Modelagem de software com a UML

### O que é a UML e por que utilizá-la?

- A UML é uma linguagem de modelagem que tem como objetivo auxiliar os engenheiros de software na definição de características, requisitos, comportamentos, estruturas lógicas, dinâmicas de processos e necessidades físicas do equipamento para o qual o sistema será implantado (GUEDES, 2011, p. 19);
- A UML originou-se para “ser um padrão que resolva as necessidades práticas da comunidade de desenvolvimento de software” (PENDER, 2004, p. 7);
- Segundo Blaha e Rumbaugh (2006), os modelos de software apresentam algumas finalidades, como:
  - Testar uma entidade física antes de construí-la: os modelos possibilitam simular o funcionamento de um software, verificando como irá se comportar em determinadas situações e corrigindo erros antes de gastar tempo e recursos em programação;
  - Comunicar as partes interessadas: os modelos permitem estabelecer um canal de comunicação efetivo com os clientes durante a definição de requisitos e o processo de desenvolvimento do software;
  - Visualizar: os modelos, sendo representações do software, facilitam um entendimento comum entre clientes e desenvolvedores;
  - Reduzir a complexidade: os modelos promovem a representação e a visualização holística (como um todo) de sistemas que são complexos para um formato de fácil compreensão.
- Sendo um processo característico da Engenharia de software, a modelagem tem uma série de atividades que devem ser executadas, segundo Guedes (2011), as atividades que compõem a modelagem são:
  - **Levantamento e análise de requisitos**: definem-se o que o software deverá realizar (requisitos funcionais) e as diferentes formas como será executado (requisitos não funcionais);
  - **Prototipação**: elabora-se uma versão primária do sistema que será desenvolvido, abrangendo como será o fluxo de informações desse sistema, seus componentes principais, dentre outros;
  - **Definição de prazos e custos**: determinam-se os recursos humanos e materiais que serão utilizados no projeto, bem como o cronograma e a duração das atividades;
  - **Projeto**: desenvolve-se a arquitetura do sistema (o projeto detalhado) e o protótipo é transformado em um modelo que descreve o modo que cada componente será aplicado no sistema e quais resultados deverão ser obtidos;
  - **Manutenção**: como será a política de manutenção e como se pode reduzir a necessidade de manutenções nele;
  - **Documentação histórica**: documentação de todo o projeto de software de modo que, caso haja mudança das equipes de desenvolvimento, o projeto tenha continuidade.
- Itens da UML:
  - **Classes**: itens que descrevem um conjunto de objetos com as mesmas características;
  - **Interface**: item que retrata o comportamento externo de uma classe ou componente;
  - **Caso de uso**: diagrama que descreve as ações realizadas pelo usuário e pelo sistema, de modo a visualizar as interações feitas por esse sistema;
  - **Ator**: elemento que interage com o sistema, como um usuário;
  - **Componentes**: elementos que modulam o sistema;
  - **Nós**: elementos físicos que contêm memória e capacidade de processamento;
  - **Máquinas de estado**: comportamentos que representam sequências de estados de um sistema.
- Relacionamentos da UML:
  - **Associação**: relacionamento simples entre dois elementos, conectando-os entre si e demonstrando qual parte de um elemento se relaciona com o elemento de outra parte;
  - **Dependência**: relacionamento de dependência entre dois elementos, com um independente e outro dependente – a alteração do elemento independente resulta, necessariamente, na alteração do dependente;
  - **Generalização**: relacionamento de especialização e generalização, no qual os elementos especializados herdam características dos elementos generalizados;
  - **Realização**: relacionamento no qual um elemento especifica as regras que o outro elemento deve executar.

### Diagramas comportamentais

- Diagrama de caso de uso:
  - Foi um dos primeiros diagramas elaborados no processo de modelagem de software e é amplamente utilizado para a definição de requisitos funcionais e não funcionais;
  - O diagrama de caso de uso apresenta as possíveis situações de uso do sistema por parte do usuário;
  - Os usuários são representados como atores e interagem com o sistema por meio de suas funcionalidades (caso de uso), representadas por frases escritas dentro de uma figura no formato de elipse;
  - Cada caso de uso tem um relacionamento com o ator que o realiza, seja usuário ou sistema;
  - O relacionamento de **extensão** consiste na adição das características de um caso de uso em um segundo caso de uso e é representado por uma flecha tracejada com a palavra "<\<extend>>" na parte superior, apontada para o caso de uso estendido
  - O relacionamento de inclusão significa que o primeiro caso de uso também conterá características do segundo, denominado caso de uso de inclusão, e é representado por uma flecha tracejada com a palavra "<\<include>>" na parte superior, apontada para o caso de uso incluído;
  - O relacionamento de generalização, por sua vez, indica que o primeiro caso de uso consiste em uma especialização do caso de uso ou ator e é representado por uma seta em linha sólida apontando para o caso de uso ou ator mais geral.
- Diagrama de sequência:
  - Esse diagrama descreve a sequência de execução do sistema, dando ênfase à troca de mensagens entre atores, interfaces e sistema;
  - Nesse diagrama, o usuário (ou ator) e os demais elementos da UML são representados na parte superior do diagrama. Porém, há uma linha tracejada vertical (linha de vida) abaixo deles, que representa a existência e a atuação desses objetos de acordo com o tempo (quanto mais para baixo, mais tempo passou);
  - Há retângulos sobre cada linha vertical, que representam o momento em que o ator, interface ou componente do sistema é chamado e executa uma atividade;
  - As flechas horizontais representam as trocas de mensagens ocorridas entre os objetos, as quais partem da origem até o destinatário;
  - Quando essa flecha é de espessura fina, a mensagem é assíncrona, ou seja, não necessariamente possuirá uma mensagem de retorno correspondente, já quando a flecha é de espessura maior com linha triangular cheia, a mensagem é síncrona, ou seja, possuirá uma mensagem correspondente de retorno (por exemplo, uma chamada).
- Diagrama de comunicação:
  - Um diagrama de comunicação enfatiza a participação e a interação entre os elementos de um sistema, bem como as comunicações existentes e as mensagens trocadas entre esses objetos;
  - Primeiramente, inserem-se nesse diagrama os elementos participantes dessa interação;
  - Depois, conectam-se os elementos por meio de linhas cheias e flechas representando as mensagens trocadas entre esses elementos;
  - Cada mensagem é sequenciada por meio de um número (por exemplo, 1, 2, 3...).
- Diagrama de gráfico de estados:
  - Esse diagrama exibe uma máquina de estados, ou seja, apresenta os estados de atividades de um sistema, assim como os fluxos entre um estado e outro;
  - Esses estados são representados por retângulos com bordas arredondadas, podendo estar inseridos dentro de um estado aninhado (representado da mesma forma, só que no formato de um retângulo maior que inclui os demais);
  - O estado inicial é representado por um círculo e as setas representam a evolução entre um estado e outro, bem como as mensagens e condições para a transição entre os estados acontecer;
- Diagrama de atividades:
  - Esse diagrama mostra a sequência de atividades realizadas pelo sistema, abrangendo condições para a realização de uma atividade ou outra (representadas no diagrama por losangos), atividades realizadas em paralelo (representadas por barras horizontais de cor escura), dentre outras;
  - Similarmente ao diagrama de gráfico de estados, as atividades também são representadas por retângulos com bordas arredondadas, o início das atividades por um círculo e a sequência das atividades por flechas;
  - Há a possibilidade de inclusão de condições para que determinada atividade, ou outra, seja realizada por meio de losangos contendo cada condição;
  - Ao mesmo tempo, há a possibilidade da representação de atividades sendo realizadas em paralelo, por meio de uma barra horizontal inserida no local onde o paralelismo inicia.

### Diagramas estruturais

- Os diagramas estruturais “existem para visualizar, especificar, construir e documentar os aspectos estáticos de um sistema” (BOOCH, RUMBAUGH; JACOBSON, 2005, p. 96), ou seja, enfatizam os aspectos estruturais e técnicos de um sistema, como classes, interfaces, componentes, dentre outros;
- Diagramas de classes:
  - Esses diagramas são “encontrados com maior frequência na modelagem de sistemas orientados a objetos” (BOOCH, RUMBAUGH; JACOBSON, 2005, p. 107);
  - As associações entre classes, ou entre objetos, são feitas por flechas de relacionamentos, a representação de uma classe é feita por um retângulo segmentado em três partes por meio de uma linha horizontal;
  - A parte superior contém o nome, ou identificação, da classe, e a parte inferior, por sua vez, contém os métodos ou funções executadas pela classe.
- Diagrama de componentes:
  - Esses diagramas visam a representação de componentes ou partes segmentáveis de um sistema;
  - Um componente é um segmento de um sistema que possibilita interações e trocas de serviços e mensagens com outra parte do sistema;
  - Os componentes interagem entre si e com as classes por meio de relacionamentos ou por interfaces;
  - Interface “é uma coleção de operações utilizadas para especificar um serviço de uma classe ou de um componente” (BOOCH et al., 2005, p. 197);
  - Desse modo, interfaces podem ser fornecidas por componentes e requeridas por outros, que ao receberem-nas podem entrar em funcionamento.
- Diagrama de artefatos:
  - Esse diagrama permite a representação de aspectos físicos de um sistema, como arquivos, páginas de internet e bancos de dados;
  - Esses diagramas são úteis para a visualização das relações entre o sistema e os componentes físicos – por exemplo, quais arquivos ou bibliotecas se relacionam entre si e em qual linguagem (ou extensão), ou a relação entre as diferentes tabelas de um banco de dados entre si e com outras partes do sistema.
- Diagrama de implantação:
  - Esse diagrama representa os aspectos de implantação de um sistema após ser desenvolvido, contemplando comunicação de rede, estrutura de hardware e nós de processamento;
  - Assim como em outros diagramas, é possível inserir relacionamentos, como dependência e associação, entre os elementos desse diagrama;

## Gestão de projetos de software

### Projeto de software: elementos básicos

- Desenvolver um software significa administrar e realizar projetos;
- De acordo com o PMBOK (Project Management Body of Knowledge) – uma das principais referências em gestão de projetos –, um projeto é “um esforço temporário empreendido para criar um produto, serviço ou resultado único. A natureza temporária dos projetos indica que eles têm um início e um término definidos” (PMI, 2014, p. 26);

#### Escopo

- O escopo consiste na definição de como será realizado um projeto;
- No caso de um software, o escopo define, portanto, as funcionalidades que serão ou não implantadas e os requisitos funcionais e não funcionais desse projeto;
- Para a definição do escopo de um projeto, pode-se utilizar várias técnicas, como a realização de entrevistas com as partes interessadas, de modo a identificar as necessidades de desenvolvimento e os requisitos;
- Estrutura Analítica do Projeto (EAP): uma das formas de documentar o escopo de um projeto e seus requisitos funcionais e não funcionais, consiste em dividir as entregas do projeto em subentregas, de modo que possam ser gerenciadas em partes, o que facilita o desenvolvimento do projeto como um todo;
- Para estabelecer o tamanho de um sistema, pode-se utilizar a técnica denominada contagem de pontos de função, mediante a qual o tamanho do projeto é calculado com base na “complexidade de fluxo de dados através das interfaces e funções de um produto, por meio de regras padronizadas” (PAULA FILHO, 2009, p. 515);
- Entradas externas: processo pelo qual os dados se integram no sistema de fora para dentro;
- Consultas externas: recuperações de dados de um ou mais arquivos lógicos;
- Saídas externas: processo pelo qual os dados derivados se apresentam ao usuário, ou seja, cruzam o sistema de dentro para fora;
- Arquivos lógicos internos: dados logicamente correlatos, possíveis de identificação pelo usuário, que se encontram dentro de um aplicativo e mantido por meio de entradas externas;
- Arquivos de interface externa: dados logicamente correlatos, possíveis de identificação pelo usuário, mas consultados apenas pelo sistema, sendo mantidos por outros aplicativos;

#### Tempo

- Desenvolver um software é uma atividade com início, meio e fim. Sendo assim, é preciso considerar os impactos relacionados ao tempo necessário para realizar esse desenvolvimento;
- Um dos meios mais eficazes de realizar a gestão do tempo de um projeto de software é a elaboração de um cronograma, que, segundo o PMI (2014), pode ser de diferentes formas:
  - Consulta a opiniões de especialistas para verificar o tempo de duração estimado para cada atividade;
  - Uso de técnicas analíticas, como estudos, para verificar o tempo de desempenho de cada tarefa;
  - Realização de reuniões com a equipe de desenvolvimento para discutir esse cronograma.
- Sugere-se que a elaboração do cronograma seja feita com base nas entregas e subentregas propostas na EAP. Cada subentrega deve ser realizada conforme determinado prazo, com marcos sinalizando a data final de cada entrega.

#### Custos

- O gerenciamento dos custos, é possível a contar do momento em que se sabe o que precisa ser desenvolvido (o escopo) e a quantidade de tempo disponível a ser alocada;
- Os analistas de desenvolvimento de software, por exemplo, geralmente são profissionais que têm seus custos mensurados por tempo, ou seja, por horas, meses e anos;
- O mesmo vale para serviços como hospedagem na nuvem, licenças de software e aluguel de equipamentos;
- Dessa forma, preferencialmente antes de se executar um projeto, ou uma fase dele, torna-se necessária a realização de uma estimativa de custos tanto fixos (que não dependam de tempo de desenvolvimento) quanto variáveis (que dependem da quantidade de tempo), que possam impactar o desenvolvimento do projeto.

#### Qualidade

- A qualidade de um projeto de software diz respeito à sua adequabilidade aos requisitos e aos interesses das partes envolvidas, a qual pode ser mensurada por métricas ou indicadores de qualidade;
- Alguns exemplos de métricas em projetos de software são:
  - Tempo dispendido por funcionalidade desenvolvida;
  - Quantidade de linhas de código desenvolvidas por hora;
  - Custo total do projeto por mês;
  - Aquisições efetuadas por mês;
  - Probabilidade de determinado risco ocorrer no projeto.
- Outra forma de avaliar a qualidade de um projeto é por meio da realização de auditorias da qualidade;
- Essas auditorias podem ser realizadas pelo pessoal interno do projeto (primeira parte), por fornecedores (segunda parte) ou por um organismo de certificação (terceira parte);
- Os resultados das auditorias são geralmente descritos em um relatório, em que se evidencia as conformidades e não conformidades do processo auditado.

### Projeto de software: elementos acessórios

#### Riscos

- Além de escopo, custo, tempo e qualidade, existem outros componentes que devem ser considerados na elaboração, realização e análise de um projeto de software;
- Um software ou sistema apresenta riscos no processo de desenvolvimento, os quais geralmente são mensurados por meio de duas variáveis básicas, probabilidade e impacto:
  - Probabilidade: diz respeito às possibilidades quantitativas de o risco se transformar no acontecimento de fato e geralmente é mensurada em termos de porcentagem: quanto maior for a porcentagem, maiores serão as chances de o risco se concretizar;
  - Impacto: diz respeito aos possíveis acontecimentos que impactarão positiva ou negativamente o projeto como um todo. São exemplos de impactos: perdas materiais ou financeiras, atrasos no cronograma do projeto, problemas na equipe de trabalho, entre outros.

#### Comunicação

- A comunicação é essencial em um projeto de software, principalmente quando há múltiplas equipes de desenvolvimento;
- A comunicação pode ser feita por meio de reuniões, dispositivos de comunicação (chats, por exemplo), redes sociais, newsletters (informativos), murais, veículos de comunicação de massa etc;
- Dentre o que necessita ser comunicado em um projeto, encontram-se a sua situação atual, informações essenciais para o desenvolvimento, necessidades de recursos, potenciais riscos que possam surgir durante o desenvolvimento, dentre outros;
- Murais Kanban, se tornam essenciais para que todas as equipes saibam, mutuamente, em que estágio cada uma está no desenvolvimento de seu componente;
- Outro exemplo do uso da comunicação é no método de desenvolvimento scrum.

#### Recursos humanos

- A gestão de pessoas também é relevante para o sucesso de um projeto de software, principalmente devido à possibilidade de haver equipes multidisciplinares – equipes com profissionais de diferentes áreas do conhecimento e origens culturais;
- Para que os recursos humanos do projeto sejam aproveitados, algumas atividades são necessárias:
  - A primeira é a mobilização da equipe do projeto, que consiste na contratação dos membros do projeto;
  - Outra atividade é o desenvolvimento, que se relaciona com as iniciativas de treinamento e a capacitação das equipes do projeto.

#### Aquisições

- Em relação as aquisições, vale destacar a necessidade de compras de ativos, como servidores, computadores, dispositivos de comunicação móvel, serviços de telecomunicações, hospedagem de conteúdo na nuvem, entre outros;
- O gerenciamento das aquisições em um projeto é realizado por meio de três etapas essenciais:
  - Planejamento: planeja-se o que se pretende adquirir, com a análise e avaliação de propostas e a realização de negociações com os fornecedores conforme necessário;
  - Condução: realizam-se a aquisição e o pagamento dos recursos adquiridos, além do acompanhamento da aquisição para verificar se o recurso adquirido chegará com sucesso ao local da entrega;
  - Controle: controlam-se as aquisições e realizam-se inspeções e auditorias para verificar se o conteúdo recebido corresponde ao que foi solicitado e, caso necessário, são feitas reivindicações com o fornecedor.

#### Integração

- A integração envolve as atividades de abertura, planejamento, mudanças e encerramento do projeto, abrangendo os demais componentes do projeto, como escopo, custos, tempo, qualidade, riscos, comunicação, recursos humanos e aquisições, desde o início até o final;
- O termo de abertura é um dos documentos mais relevantes, pois autoriza o início do projeto e descreve seus itens como responsabilidades, requisitos, entregas, premissas e restrições;
- Outro documento relevante é o plano de gerenciamento do projeto, que descreve as diretrizes necessárias para gerenciar o projeto como um todo, servindo de base para o planejamento das demais partes componentes.

### Projetos de arquiteturas de software

- De acordo com Sommerville (2011), as arquiteturas de software podem ser de pequena ou grande escala:
  - Arquitetura de pequena escala: projeto de arquiteturas de software individuais, ou seja, de como cada programa é dividido em seus componentes menores;
  - Arquitetura de grande escala: sistemas de maior complexidade, geralmente distribuídos em mais de um computador.
- Por descrever o modo de funcionamento de um sistema, a arquitetura pode ser reaproveitada para o projeto de sistemas com finalidades semelhantes, sem que se tenha que gastar tempo e recursos com o desenvolvimento de funcionalidades;
- Arquitetura centralizada em dados:
  - Conforme o nome sugere, insere-se um repositório de armazenamento de dados em seu centro, sendo acessado por softwares ou componentes clientes que transitam ao seu redor e "que atualizam, acrescentam, eliminam ou modificam de alguma maneira os dados contidos no repositório" (PRESSMAN; MAXIM, 2016, p. 259);
  - Uma vantagem desse tipo de arquitetura reside nos softwares clientes, que podem ser alterados de modo independente, tendo em vista que dependem apenas do repositório de dados.
- Arquitetura de fluxo de dados:
  - É utilizada quando é necessária a visualização das entradas e saídas de dados de um sistema ou entre seus componentes;
  - Utiliza-se um padrão denominado tubos-e-filtro, no qual os componentes do sistema representam filtros de dados, e o fluxo de dados entre um componente e outro é denominado tubo.
- Arquitetura de programa principal e subprograma:
  - Estabelece uma hierarquia em que um programa principal administra componentes controladores, que por sua vez administram aplicações;
  - De acordo com Pressman e Maxim (2016), esse tipo de arquitetura permite uma fácil atualização do sistema como um todo e dos seus componentes, bem como uma fácil ampliação desse sistema;
  - Cada subprograma de aplicação executa uma funcionalidade do sistema como um todo, sendo controlados pelos subprogramas controladores.
- Arquitetura em camadas:
  - Consiste na segmentação dos componentes de software em diferentes camadas de operações, sendo que, quanto mais próximo à camada central, mais próximas as informações se tornam de um conjunto de instruções de máquina;
  - Quanto mais externa for a camada, mais próxima ela se aproxima da interface do usuário, que é a parte do sistema que interage com a pessoa que o utiliza;
  - Um exemplo de aplicação desse tipo de arquitetura é o padrão MVC (Model-View-Controller).

## Gestão da qualidade em engenharia de software

### Normas de qualidade

- As normas de qualidade têm como propósito fornecer os subsídios necessários para a gestão e o controle adequados das atividades de desenvolvimento de software, para que toda entrega atenda aos requisitos esperados;
- A norma mais básica de gestão da qualidade para softwares ou demais produtos e serviços é a NBR ISO 9000:2015, a qual estabelece que a qualidade consiste em um conjunto de características que satisfaçam os requisitos (ABNT, 2015a);
- A norma NBR ISO 9001:2015 (ABNT, 2015b) é a versão mais atual da série ISO 9000 e contempla, ao todo, 10 capítulos;
- **Contexto da organização (Capítulo 4)**: este capítulo trata das necessidades e expectativas das partes interessadas e do escopo do sistema de gestão, ou seja, define o que a organização entrega de produtos e serviços às partes interessadas;
- **Liderança (Capítulo 5)**: este capítulo trata do papel da alta direção e das lideranças na promoção do sistema de gestão da qualidade, sobre o
  desenvolvimento de uma política de qualidade e de papéis, responsabilidades e autoridades organizacionais;
- **Planejamento (Capítulo 6)**: este capítulo aborda a necessidade de planejamento organizacional para administrar os riscos e as oportunidades inerentes à atividade que a organização desempenha, bem como os objetivos da qualidade e as mudanças a serem realizadas na organização;
- **Apoio (Capítulo 7)**: este capítulo aborda a gestão de recursos materiais e humanos, bem como a infraestrutura necessária para a execução das atividades. Além disso, trata do ambiente operacional, que deve ser adequado social, psicologica e fisicamente;
- **Operação (Capítulo 8)**: este capítulo aborda as ações que viabilizam a atividade operacional nas organizações, bem como o planejamento e controle operacional e os controles de processos. Quanto aos produtos e serviços, trata da definição de seus requisitos, do projeto e do desenvolvimento deles, daqueles fornecidos por uma entidade externa, da atividade produtiva e da liberação deles ao cliente;
- **Avaliação de desempenho (Capítulo 9)**: este capítulo trata dos instrumentos de avaliação do desempenho dos serviços de uma organização, que pode ser por meio da satisfação do cliente, da auditoria interna e da análise crítica pela direção;
- **Melhoria (Capítulo 10)**: este capítulo enfatiza que a organização deve adotar ações para a promoção da melhoria contínua dos seus processos, corrigindo, prevenindo ou reduzindo quaisquer efeitos indesejados.

### Qualidade em software

- Devido à complexidade de muitos sistemas, existe a possibilidade de ocorrerem falhas ou operações indesejadas, prejudicando o desempenho do sistema como um todo e impactando negativamente na organização-cliente do sistema. Assim, é necessário que a qualidade seja adequadamente planejada, gerenciada e controlada, de modo que, no projeto do software, os requisitos sejam plenamente atendidos e o produto ou serviço final entregues estejam adequados às necessidades da organização-cliente.

#### Fatores de qualidade em um produto de software

- McCall, Richards e Walters (1977 apud PRESSMAN; MAXIM, 2016) definem uma série de fatores que devem ser considerados para a avaliação da qualidade em um produto de software;
- Grupo **revisão do produto**:
  - **Facilidade de manutenção**: quantidade de recursos e esforços necessários para encontrar e corrigir erros;
  - **Flexibilidade**: recursos e esforços necessários para modificar um software em desenvolvimento ou acabado;
  - **Testabilidade**: esforços necessários para a realização de testes, verificando se o software atende às necessidades e aos requisitos.
- Grupo **transição do produto**:
  - **Portabilidade**: recursos necessários para a transferência de um software de um hardware a outro;
  - **Reusabilidade**: o quanto um software (ou partes do código) pode ser reaproveitado para o desenvolvimento de outros sistemas;
  - **Interoperabilidade**: capacidade de integração do software com outros softwares e hardwares, formando um sistema integrado.
- Grupo **operação de produto**:
  - **Correção**: o quanto um software é correto, ou seja, o quanto atende às especificações e requisitos definidos;
  - **Confiabilidade**: o quão preciso é o software para o cumprimento de suas funções, sem a ocorrência de erros ou falhas;
  - **Eficiência**: quantidade de recursos computacionais (memória RAM, uso de processador e espaço em HD, por exemplo) necessários para a execução;
  - **Integridade**: segurança do software, ou seja, a prevenção ao acesso por parte de pessoas não autorizadas;
  - **Usabilidade**: esforços necessários para aprender a utilizar o software corretamente.

### Garantia de qualidade em software

- Para a garantia da qualidade, faz-se necessária, na engenharia de software, a implementação de processos, desde o início do desenvolvimento do código até a entrega do software ou sistema finalizado, para que, uma vez entregue ao cliente, funcione corretamente;
- A garantia da qualidade é obtida por meio da padronização dos processos de desenvolvimento, que segue algumas normas, como as definidas pelos organismos internacionais IEEE e ISO;
- No processo de desenvolvimento de software, é importante a realização periódica de revisões de código em busca de erros;
- Outra ferramenta relevante para a garantia de qualidade consiste na realização de auditorias periódicas no projeto, que podem ser feitas por membros da própria equipe de desenvolvimento ou por pessoas externas;
- Em conjunto à execução de revisões e auditorias, a realização de testes permite a detecção de não conformidades nos processos de desenvolvimento, bem como a detecção de erros no projeto;
- Além de erros e defeitos no projeto, outra questão a se considerar é a segurança dos dados que estão sendo processados ou que o software, uma vez acabado, irá processar;
- A garantia da qualidade também contempla ações de verificação de potenciais erros ou defeitos que possam causar danos, principalmente no caso de softwares direcionados às indústrias altamente sensíveis, como a automobilística e a aeronáutica;
- A garantia deve acontecer durante todo o processo de desenvolvimento de um software. A realização de revisões e conferências periódicas aumenta a segurança do código e contribui para a sua segurança e adequação aos requisitos funcionais e não funcionais.

### Melhorias em software

- Um dos principais motivos para a adoção de práticas de gestão da qualidade nas organizações, incluindo as de desenvolvimento de software, é a realização de melhorias contínuas nos processos dessas organizações;
- **Abordagem de maturidade de processo**: "se centra em melhorar o gerenciamento de processos e projetos e em introduzir boas práticas de engenharia de software em uma organização" (SOMMERVILLE, 2011, p. 493). O foco consiste no desenvolvimento de processos maduros, estruturados e previsíveis, de modo a garantir maior segurança no desenvolvimento de software, bem como na realização de mudanças e melhorias;
- **Abordagem ágil**: "se centra no desenvolvimento iterativo e na redução de overheads gerais no processo de software" (SOMMERVILLE, 2011, p. 493, grifo do original). O foco consiste na realização de entregas rápidas de funcionalidades, ou seja, as mudanças e melhorias nos processos de desenvolvimento são efetuadas rapidamente de acordo com as mudanças de requisitos fornecidas pelo cliente.

#### Roteiro para a melhoria dos processos de desenvolvimento de software

- Ciclo de melhorias de processos:
  - Medir: medir o seu processo atual e a qualidade dos produtos e serviços desenvolvidos;
  - Analisar: analisar o processo atual e verificar a existência de pontos fracos;
  - Mudar: implantar mudanças para a solução dos problemas e, então, o ciclo se reinicia.
- Pressman e Maxim (2016) sugerem um roteiro (sequência de atividades) composto de cinco atividades:
  1. **Avaliação e análise de lacunas**: levantam-se os pontos fortes e fracos do processo atual de desenvolvimento de software utilizado. Verificam-se se os processos de desenvolvimento têm objetivos claramente definidos, se os critérios de entrada e saída foram adequadamente definidos, se há métricas estabelecidas para a atividade e se o processo é executado de maneira uniforme para todos os projetos de software;
  2. **Realização de ações de educação e treinamento**: antes de se realizar mudanças no processo de desenvolvimento de software, recomenda-se que os colaboradores envolvidos sejam conscientizados sobre a necessidade de um processo eficaz e organizado;
  3. **Seleção e justificação**: com base na avaliação e análise de lacunas, deve-se optar por manter o processo atual de desenvolvimento de software ou adotar um que se torne mais adequado para a equipe de desenvolvimento;
  4. **Instalação e migração**: etapa na qual a organização desenvolve um processo inteiramente novo ou implanta a mudança de processo selecionada na etapa anterior;
  5. **Mensuração**: deve ser realizada durante todas as etapas de desenvolvimento, por meio de fatores qualitativos e indicadores quantitativos, para verificar se o processo de mudança atende às necessidades da organização.

#### Atributos de processo de software para a melhoria contínua

- Sobre a melhoria em processos de desenvolvimento, Sommerville (2011) enumera alguns atributos de processo que devem ser considerados:
  - **Compreensibilidade**: verifica-se o quanto o processo é definido de modo explícito, bem como sua compreensão por parte da equipe de desenvolvimento;
  - **Padronização**: observa-se o quanto o processo se assemelha a um processo genérico padrão e se esse mesmo processo é utilizado em todas as equipes de desenvolvimento;
  - **Visibilidade**: avalia-se se as atividades do processo resultam em produtos e serviços claramente definidos e se, quando o processo é aplicado, seu progresso é claramente percebido;
  - **Capacidade de medição**: analisa-se se existe a coleta de dados necessária para a estruturação de indicadores quantitativos para a avaliação eficaz do desempenho do processo;
  - **Capacidade de apoio**: confere-se se as ferramentas de software, atualmente usadas, são capazes de apoiar as atividades desempenhadas pelo processo;
  - **Aceitabilidade**: comprova-se se o processo é aceito pelas equipes de desenvolvimento, sendo plenamente utilizado pelos engenheiros de software;
  - **Confiabilidade**: constata-se se o processo é projetado de modo que erros sejam evitados, visto que, se ignorados, podem ser transmitidos para o produto final, prejudicando a sua qualidade;
  - **Robustez**: examina-se se o processo resiste a incidentes ou problemas, mantendo a sua continuidade;
  - **Manutenibilidade**: confirma-se a capacidade de evolução do processo para reagir a mudanças nas necessidades da organização ou dos clientes;
  - **Rapidez**: investiga-se a rapidez do processo na realização de entregas de software, ou seja, a sua conclusão após a entrega de uma determinada especificação de software.

## Testes e engenharia reversa em software

- Um software, como qualquer produto, necessita passar por testes em todo o processo de desenvolvimento, e não apenas quando está “finalizado”, ou seja, deve ser testado desde o projeto, passando pela modelagem, até a construção e entrega ao cliente.

### Modalidades de testes em software

- Quando efetuado de modo adequado, um teste pode expor vários tipos de defeitos que, ao serem prontamente corrigidos, provavelmente, resultarão em economia de esforços e recursos financeiros;
- Pfleeger (2004) enumera algumas ocorrências de defeitos possíveis em um sistema:
  - **Algoritmo**: ocorrem quando a lógica de um código criado resulta em uma saída indesejada ao testá-lo;
  - **Computação e precisão**: pode acontecer, por exemplo, quando o computador não calcula determinada fórmula com o grau de precisão requerido pelo software, resultando em saídas imprecisas;
  - **Documentação**: quando a documentação elaborada para o software não corresponde ao que o produto de fato desempenha;
  - **Capacidade**: quando o software não atende à capacidade de processamento à qual deveria;
  - **Defeitos de recuperação**: quando ocorre falha no funcionamento de um software, como quando um sistema operacional “trava”, a tendência é que seu pleno funcionamento seja recuperado ao ser reativado, o que não acontece com sistemas que apresentam defeitos de recuperação.
- Paula Filho (2009), Pfleeger (2004) e Sommerville (2011) sugerem, cada qual com seu ponto de vista, vários testes que podem ser adotados para a detecção de falhas:
  - **Teste de unidade**: é um dos testes com maior nível de detalhamento durante o desenvolvimento do software, que, segundo Sommerville (2011, p. 148), é o “processo de testar os componentes de programa, como métodos ou classes de objeto”, ou seja, possibilita testar cada parte de um componente;
  - **Teste de desenvolvimento**: similarmente ao de unidade, o teste de desenvolvimento é recomendado durante todas as etapas de desenvolvimento de um software ou componente, assegurando que determinado componente, quando concluído, consequentemente passe no teste de unidade e funcione adequadamente na conclusão do software como um todo;
  - **Teste de qualificação**: normalmente, é realizado quando o software, ou o seu componente, acaba de ser desenvolvido, para verificar se está de acordo com o projeto;
  - **Teste funcional**: permite verificar as funcionalidades de um sistema ou componente antes de ser colocado em ambiente de operação e é realizado “para avaliar a conformidade de um sistema ou componente com os requisitos funcionais especificados” (PAULA FILHO, 2009, p. 352);
  - **Teste operacional**: após concluído, o software deve ser testado sob condições realistas, por meio de simulações, de modo que seus componentes sejam colocados à prova e, assim, seja possível verificar precisamente se esse produto é capaz de atender aos requisitos funcionais e não funcionais definidos ou se será necessária a realização de ajustes;
  - **Teste de regressão**: consiste na análise comparativa de duas versões do software: antes e depois da realização de alterações e melhorias;
  - **Teste de integração**: o teste de integração é importante para verificar, além do funcionamento dos componentes do sistema isoladamente, a interação dos algoritmos ou códigos entre eles, bem como compatibilidade, intercâmbio de dados e saídas geradas entre esses componentes para o software como um todo;
  - **Teste de sistema**: de modo similar ao de integração, o teste de sistema envolve a interação e a troca de informações entre componentes. No entanto, o foco é a verificação do funcionamento do sistema como um todo, em uma versão funcional;
  - **Testes de usuário**: possivelmente, um dos mais relevantes, podendo permear os demais testes realizados para o software. Coletam-se informações de feedback do cliente com relação ao sistema, aos componentes, ao código, às funcionalidades, às compatibilidades, dentre outros fatores;
  - **Teste de aceitação**: esse teste permite ao usuário verificar se o software atende às suas necessidades, avaliando todos os aspectos de desenvolvimento e se existe algum defeito (de algoritmo, de computação e precisão ou de documentação).

### Realização de testes

- Há três modalidades de testes de acordo com o nível de transparência:
  - **Teste de caixa branca**: é a modalidade mais detalhada, que abrange o sistema e o funcionamento de todos os seus componentes e, portanto, “leva em conta os mecanismos internos de um sistema ou componente” (PAULA FILHO, 2009, p. 353);
  - **Teste de caixa cinza**: são considerados apenas a interação dos componentes em um sistema e o funcionamento do software como um todo, desprezando o funcionamento detalhado de um componente;
  - **Teste de caixa preta**: é a modalidade mais superficial e é utilizada para avaliar o cumprimento dos requisitos funcionais e não funcionais e verificar a compatibilidade do software com outros sistemas, uma vez que se ignora, nesse processo, a interação dos componentes internos do sistema;
- **Teste bottom-up**: aborda a realização de testes em cada componente isoladamente e, depois, nos componentes integrados entre si, até finalizar com um último teste no sistema integrado;
- **Teste top-down**: consiste na realização de testes primeiramente com o sistema como um todo, em seu nível de abstração mais elevado e, depois, com seus componentes isoladamente;
- **Teste top-down modificado**: testam-se os componentes e, em seguida, o sistema como um todo, após isso, o sistema passa novamente por testagem de seus componentes e, então, uma nova configuração de componentes integrados é testada.

### Manutenções e reengenharia

- Engenharia reversa, ou reengenharia, de software, consiste na reconstrução de um software a partir de uma solução já existente;
- Uma das vantagens desse processo é a redução de custos e esforços, à medida que o código existente já está desenvolvido;
- Outra vantagem consiste na diminuição de riscos, visto que os componentes do código desenvolvido já demonstraram, em algum momento, a funcionalidade desejada.

#### Modalidades de reengenharia de software

- **Engenharia reversa de informações**: o software é analisado como um todo e as suas informações – como código-fonte, interações entre componentes, bancos de dados, funcionalidades etc. – são extraídas para futura codificação;
- **Tradução de código-fonte**: o código-fonte do software é convertido de uma versão mais antiga para uma atual;
- **Melhoria de estrutura de programa**: modifica-se a estrutura do software e seus controles de modo a melhorar sua legibilidade;
- **Modularização de programa ou eliminação de redundâncias**: agrupam-se partes do software que possuam alguma relação entre si, e as redundâncias são removidas;
- **Adaptação dos dados processados pelo software à nova estrutura**: redefinem-se esquemas de bancos de dados e convertem-se bancos de dados existentes.

#### Processo de reengenharia de software

- **Análise do inventário**: levantamento das principais informações sobre os sistemas operacionais atualmente utilizados pela empresa, como idade, tamanho, funcionalidades, relações com outros softwares, dentre outras relevantes para se detectar possíveis softwares candidatos à reengenharia;
- **Reestruturação do código-fonte**: utilizando interfaces de desenvolvimento (IDEs) de modo a atualizar o código e torná-lo mais "limpo";
- **Engenharia reversa**: analisar o software para desenvolver sua representação de modo mais abstrato do que seu código-fonte;
- **Reestruturação da documentação**: desenvolvimento de uma documentação inteiramente nova;
- **Reestruturação dos dados**: abrange a recuperação da base de dados armazenada no software para que possa ser reaproveitada na nova versão desse software;
- **Engenharia direta**: o próprio projeto do software é utilizado como base para sua melhoria, recriando-se funcionalidades do sistema existente e acrescentando-se novas funções.
